<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Changes to &#x60;u128&#x60;/&#x60;i128&#x60; layout in 1.77 and 1.78 | Rust Blog</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
<meta name="description" content="Empowering everyone to build reliable and efficient software.">
     <!-- Twitter card -->
     <meta name="twitter:card" content="summary">
     <meta name="twitter:site" content="@rustlang">
     <meta name="twitter:creator" content="@rustlang">
     <meta name="twitter:title" content="Changes to &#x60;u128&#x60;/&#x60;i128&#x60; layout in 1.77 and 1.78 | Rust Blog">
     <meta name="twitter:description" content="Empowering everyone to build reliable and efficient software.">
    <meta name="twitter:image" content="https://www.rust-lang.org/static/images/rust-social.jpg">
    
    <!-- Facebook OpenGraph -->
    <meta property="og:title" content="Changes to &#x60;u128&#x60;/&#x60;i128&#x60; layout in 1.77 and 1.78 | Rust Blog" />
    <meta property="og:description" content="Empowering everyone to build reliable and efficient software.">
    <meta property="og:image" content="https://www.rust-lang.org/static/images/rust-social-wide.jpg" />
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="en_US" />
    
    <!-- styles -->
    <link rel="stylesheet" href="https://blog.rust-lang.org/styles/skeleton.css"/>
    <link rel="stylesheet" href="https://blog.rust-lang.org/styles/tachyons.css"/>
    <link rel="stylesheet" href="https://blog.rust-lang.org/styles/fonts.css"/>
    <link rel="stylesheet" href="https://blog.rust-lang.org/styles/app.css"/>
    <link rel="stylesheet" type="text/css" id="syntax-theme" />
    
    <!-- stylesheet for user agents without js -->
    <noscript>
        <link rel="stylesheet" href="https://blog.rust-lang.org/styles/noscript.css">
        <link rel="stylesheet" type="text/css" href="/styles/syntax-theme-dark.css" media="(prefers-color-scheme: dark)" />
        <link rel="stylesheet" type="text/css" href="/styles/syntax-theme-light.css" media="(prefers-color-scheme: light)" />
    </noscript>
    
    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="https://blog.rust-lang.org/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://blog.rust-lang.org/images/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://blog.rust-lang.org/images/favicon-32x32.png">
    <link rel="icon" type="image/svg+xml" href="https://blog.rust-lang.org/images/favicon.svg">
    <link rel="manifest" href="https://blog.rust-lang.org/images/site.webmanifest">
    <link rel="mask-icon" href="https://blog.rust-lang.org/images/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#00aba9">
    <meta name="theme-color" content="#ffffff">
    
     <!-- atom -->
     <link type="application/atom+xml" rel="alternate" href="https://blog.rust-lang.org/feed.xml" title="Rust Blog" />
    
    <!-- theme switcher -->
    <script src="https://blog.rust-lang.org/scripts/theme-switch.js"></script>
  </head>
  <body>
    <nav class="flex flex-row justify-center justify-end-l items-center flex-wrap ph2 pl3-ns pr4-ns">
      <div class="brand flex-auto w-100 w-auto-l self-start tc tl-l">
        <a href="https://blog.rust-lang.org/">
          <img class="v-mid ml0-l rust-logo" alt="Rust Logo" src="https://blog.rust-lang.org/images/rust-logo-blk.svg">
          <span class="dib ml1 ml0-l">Rust Blog</span>
        </a>
      </div>
    
      <ul class="nav list w-100 w-auto-l flex flex-none flex-row flex-wrap justify-center justify-end-l items-center pv2 ph0 ph4-ns">
        <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://www.rust-lang.org">Rust</a></li>
        <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://www.rust-lang.org/tools/install">Install</a></li>
        <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://www.rust-lang.org/learn">Learn</a></li>
        <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://www.rust-lang.org/tools">Tools</a></li>
        <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://www.rust-lang.org/governance">Governance</a></li>
        <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://www.rust-lang.org/community">Community</a></li>
        <button class="theme-icon" onclick="dropdown();">ðŸ–Œ
          <ul id="theme-choice">
            <li class="theme-item" onclick="changeThemeTo('light');">Light</li>
            <li class="theme-item" onclick="changeThemeTo('dark');">Dark</li>
            <li class="theme-item" onclick="changeThemeTo('system');">System</li>
          </ul>
        </button>
        <script src="https://blog.rust-lang.org/scripts/theme-switch-post.js"></script>
      </ul>
    </nav><section id="Changes to &#x60;u128&#x60;/&#x60;i128&#x60; layout in 1.77 and 1.78" class="white">
  <div class="w-100 mw-none ph3 mw8-m mw8-l center f3">
    <header>
      <h2>Changes to &#x60;u128&#x60;/&#x60;i128&#x60; layout in 1.77 and 1.78</h2>
      <div class="highlight mt2 mb3"></div>
    </header>

    <div class="publish-date-author">Mar. 30, 2024 &middot; Trevor Gross
     on behalf of <a href="https://www.rust-lang.org/governance/teams/lang">The Rust Lang Team</a> 
    </div>

    <div class="post">
      <p>Rust has long had an inconsistency with C regarding the alignment of 128-bit integers
on the x86-32 and x86-64 architectures. This problem has recently been resolved, but
the fix comes with some effects that are worth being aware of.</p>
<p>As a user, you most likely do not need to worry about these changes unless you are:</p>
<ol>
<li>Assuming the alignment of <code>i128</code>/<code>u128</code> rather than using <code>align_of</code></li>
<li>Ignoring the <code>improper_ctypes*</code> lints and using these types in FFI</li>
</ol>
<p>There are also no changes to architectures other than x86-32 and x86-64. If your
code makes heavy use of 128-bit integers, you may notice runtime performance increases
at a possible cost of additional memory use.</p>
<p>This post documents what the problem was, what changed to fix it, and what to expect
with the changes. If you are already familiar with the problem and only looking for a
compatibility matrix, jump to the <a href="https://blog.rust-lang.org/2024/03/30/i128-layout-update/#compatibility">Compatibility</a> section.</p>
<h1 id="background"><a class="anchor" href="#background" aria-hidden="true"></a>
Background</h1>
<p>Data types have two intrinsic values that relate to how they can be arranged in memory;
size and alignment. A type's size is the amount of space it takes up in memory, and its
alignment specifies which addresses it is allowed to be placed at.</p>
<p>The size of simple types like primitives is usually unambiguous, being the exact size of
the data they represent with no padding (unused space). For example, an <code>i64</code> always has
a size of 64 bits or 8 bytes.</p>
<p>Alignment, however, can vary. An 8-byte integer <em>could</em> be stored at any memory address
(1-byte aligned), but most 64-bit computers will get the best performance if it is
instead stored at a multiple of 8 (8-byte aligned). So, like in other languages,
primitives in Rust have this most efficient alignment by default. The effects of this
can be seen when creating composite types (<a href="https://play.rust-lang.org/?version=beta&amp;mode=debug&amp;edition=2021&amp;gist=52f349bdea92bf724bc453f37dbd32ea">playground link</a>):</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-keyword z-other z-rust">use</span> <span class="z-meta z-path z-rust">core<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-path z-rust">mem<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>align_of<span class="z-punctuation z-separator z-rust">,</span> offset_of</span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">repr</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">C</span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
</span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">Foo</span> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">a</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-storage z-type z-rust">u8</span>,  <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> 1-byte aligned
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">b</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-storage z-type z-rust">u16</span>, <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> 2-byte aligned
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">repr</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">C</span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
</span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-storage z-type z-struct z-rust">struct</span> </span><span class="z-meta z-struct z-rust"><span class="z-entity z-name z-struct z-rust">Bar</span> </span><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">a</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-storage z-type z-rust">u8</span>,  <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> 1-byte aligned
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust">    <span class="z-variable z-other z-member z-rust">b</span><span class="z-punctuation z-separator z-type z-rust">:</span> <span class="z-storage z-type z-rust">u64</span>, <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> 8-byte aligned
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-struct z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-support z-macro z-rust">println!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>Offset of b (u16) in Foo: <span class="z-constant z-other z-placeholder z-rust">{}</span><span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-separator z-rust">,</span> <span class="z-support z-macro z-rust">offset_of!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>Foo<span class="z-punctuation z-separator z-rust">,</span> b</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-support z-macro z-rust">println!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>Alignment of Foo: <span class="z-constant z-other z-placeholder z-rust">{}</span><span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-separator z-rust">,</span> <span class="z-meta z-path z-rust">align_of<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span>Foo<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-support z-macro z-rust">println!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>Offset of b (u64) in Bar: <span class="z-constant z-other z-placeholder z-rust">{}</span><span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-separator z-rust">,</span> <span class="z-support z-macro z-rust">offset_of!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>Bar<span class="z-punctuation z-separator z-rust">,</span> b</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span><span class="z-source z-rust"><span class="z-support z-macro z-rust">println!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>Alignment of Bar: <span class="z-constant z-other z-placeholder z-rust">{}</span><span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-separator z-rust">,</span> <span class="z-meta z-path z-rust">align_of<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span>Bar<span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre>
<p>Output:</p>
<pre class="z-code"><code><span class="z-text z-plain">Offset of b (u16) in Foo: 2
</span><span class="z-text z-plain">Alignment of Foo: 2
</span><span class="z-text z-plain">Offset of b (u64) in Bar: 8
</span><span class="z-text z-plain">Alignment of Bar: 8
</span></code></pre>
<p>We see that within a struct, a type will always be placed such that its offset is a
multiple of its alignment - even if this means unused space (Rust minimizes this by
default when <code>repr(C)</code> is not used).</p>
<p>These numbers are not arbitrary; the application binary interface (ABI) says what they
should be. In the x86-64 <a href="https://www.uclibc.org/docs/psABI-x86_64.pdf">psABI</a> (processor-specific ABI) for System V (Unix &amp; Linux),
<em>Figure 3.1: Scalar Types</em> tells us exactly how primitives should be represented:</p>
<table><thead><tr><th>C type</th><th>Rust equivalent</th><th><code>sizeof</code></th><th>Alignment (bytes)</th></tr></thead><tbody>
<tr><td><code>char</code></td><td><code>i8</code></td><td>1</td><td>1</td></tr>
<tr><td><code>unsigned char</code></td><td><code>u8</code></td><td>1</td><td>1</td></tr>
<tr><td><code>short</code></td><td><code>i16</code></td><td>2</td><td>2</td></tr>
<tr><td><strong><code>unsigned short</code></strong></td><td><strong><code>u16</code></strong></td><td><strong>2</strong></td><td><strong>2</strong></td></tr>
<tr><td><code>long</code></td><td><code>i64</code></td><td>8</td><td>8</td></tr>
<tr><td><strong><code>unsigned long</code></strong></td><td><strong><code>u64</code></strong></td><td><strong>8</strong></td><td><strong>8</strong></td></tr>
</tbody></table>
<p>The ABI only specifies C types, but Rust follows the same definitions both for
compatibility and for the performance benefits.</p>
<h1 id="the-incorrect-alignment-problem"><a class="anchor" href="#the-incorrect-alignment-problem" aria-hidden="true"></a>
The Incorrect Alignment Problem</h1>
<p>If two implementations disagree on the alignment of a data type, they cannot reliably
share data containing that type. Rust had inconsistent alignment for 128-bit types:</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-support z-macro z-rust">println!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>alignment of i128: <span class="z-constant z-other z-placeholder z-rust">{}</span><span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-separator z-rust">,</span> <span class="z-meta z-path z-rust">align_of<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span><span class="z-storage z-type z-rust">i128</span><span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre>
<pre class="z-code"><code><span class="z-text z-plain">// rustc 1.76.0
</span><span class="z-text z-plain">alignment of i128: 8
</span></code></pre>
<pre data-lang="c" class="language-c z-code"><code class="language-c" data-lang="c"><span class="z-source z-c"><span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">printf</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>alignment of __int128: <span class="z-constant z-other z-placeholder z-c">%zu</span><span class="z-constant z-character z-escape z-c">\n</span><span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span><span class="z-punctuation z-separator z-c">,</span> <span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">_Alignof</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c">__int128</span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span></span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
</span></code></pre>
<pre class="z-code"><code><span class="z-text z-plain">// gcc 13.2
</span><span class="z-text z-plain">alignment of __int128: 16
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">// clang 17.0.1
</span><span class="z-text z-plain">alignment of __int128: 16
</span></code></pre>
<p>(<a href="https://godbolt.org/z/h94Ge1vMW">Godbolt link</a>) Looking back at the <a href="https://www.uclibc.org/docs/psABI-x86_64.pdf">psABI</a>, we can see that Rust has
the wrong alignment here:</p>
<table><thead><tr><th>C type</th><th>Rust equivalent</th><th><code>sizeof</code></th><th>Alignment (bytes)</th></tr></thead><tbody>
<tr><td><code>__int128</code></td><td><code>i128</code></td><td>16</td><td>16</td></tr>
<tr><td><code>unsigned __int128</code></td><td><code>u128</code></td><td>16</td><td>16</td></tr>
</tbody></table>
<p>It turns out this isn't because of something that Rust is actively doing incorrectly:
layout of primitives comes from the LLVM codegen backend used by both Rust and Clang,
among other languages, and it has the alignment for <code>i128</code> hardcoded to 8 bytes.</p>
<p>Clang uses the correct alignment only because of a workaround, where the alignment is
manually set to 16 bytes before handing the type to LLVM. This fixes the layout issue
but has been the source of some other minor problems.<sup class="footnote-reference" id="fr-f128-segfault-1"><a href="#fn-f128-segfault">1</a></sup><sup class="footnote-reference" id="fr-va-segfault-1"><a href="#fn-va-segfault">2</a></sup>
Rust does no such manual adjustement, hence the issue reported at
<a href="https://github.com/rust-lang/rust/issues/54341">https://github.com/rust-lang/rust/issues/54341</a>.</p>
<h1 id="the-calling-convention-problem"><a class="anchor" href="#the-calling-convention-problem" aria-hidden="true"></a>
The Calling Convention Problem</h1>
<p>There is an additional problem: LLVM does not always do the correct thing when passing
128-bit integers as function arguments. This was a <a href="https://github.com/llvm/llvm-project/issues/41784">known issue in LLVM</a>, before its
<a href="https://github.com/rust-lang/rust/issues/54341#issuecomment-1064729606">relevance to Rust was discovered</a>.</p>
<p>When calling a function, the arguments get passed in registers (special storage
locations within the CPU) until there are no more slots, then they get "spilled" to
the stack (the program's memory). The ABI tells us what to do here as well, in the
section <em>3.2.3 Parameter Passing</em>:</p>
<blockquote>
<p>Arguments of type <code>__int128</code> offer the same operations as INTEGERs, yet they do not
fit into one general purpose register but require two registers. For classification
purposes <code>__int128</code> is treated as if it were implemented as:</p>
<pre data-lang="c" class="language-c z-code"><code class="language-c" data-lang="c"><span class="z-source z-c"><span class="z-storage z-type z-c">typedef</span> <span class="z-storage z-type z-c">struct</span> <span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span>
</span></span><span class="z-source z-c"><span class="z-meta z-block z-c">    <span class="z-storage z-type z-c">long</span> low<span class="z-punctuation z-separator z-c">,</span> high<span class="z-punctuation z-terminator z-c">;</span>
</span></span><span class="z-source z-c"><span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-end z-c">}</span></span> <span class="z-entity z-name z-type z-typedef z-c">__int128</span><span class="z-punctuation z-terminator z-c">;</span>
</span></code></pre>
<p>with the exception that arguments of type <code>__int128</code> that are stored in memory must be
aligned on a 16-byte boundary.</p>
</blockquote>
<p>We can try this out by implementing the calling convention manually. In the below C
example, inline assembly is used to call <code>foo(0xaf, val, val, val)</code> with <code>val</code> as
<code>0x11223344556677889900aabbccddeeff</code>.</p>
<p>x86-64 uses the registers <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, and <code>r9</code> to pass function
arguments, in that order (you guessed it, this is also in the ABI). Each register
fits a word (64 bits), and anything that doesn't fit gets <code>push</code>ed to the stack.</p>
<pre data-lang="c" class="language-c z-code"><code class="language-c" data-lang="c"><span class="z-source z-c"><span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> full example at &lt;https://godbolt.org/z/5c8cb5cxs&gt; <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span><span class="z-source z-c">
</span><span class="z-source z-c"><span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> to see the issue, we need a padding value to &quot;mess up&quot; argument alignment <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span><span class="z-source z-c"><span class="z-storage z-type z-c">void</span> <span class="z-meta z-function z-c"><span class="z-entity z-name z-function z-c">foo</span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-storage z-type z-c">char</span> <span class="z-variable z-parameter z-c">pad</span><span class="z-punctuation z-separator z-c">,</span> __int128 <span class="z-variable z-parameter z-c">a</span><span class="z-punctuation z-separator z-c">,</span> __int128 <span class="z-variable z-parameter z-c">b</span><span class="z-punctuation z-separator z-c">,</span> __int128 <span class="z-variable z-parameter z-c">c</span><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-meta z-function z-c"> </span><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span></span></span><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-meta z-function-call z-c"><span class="z-support z-function z-C99 z-c">printf</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span><span class="z-constant z-other z-placeholder z-c">%#x</span><span class="z-constant z-character z-escape z-c">\n</span><span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span><span class="z-punctuation z-separator z-c">,</span> pad <span class="z-keyword z-operator z-c">&amp;</span> <span class="z-constant z-numeric z-integer z-hexadecimal z-c"><span class="z-punctuation z-definition z-numeric z-base z-c">0x</span>ff</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">print_i128</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c">a</span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">print_i128</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c">b</span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-meta z-function-call z-c"><span class="z-variable z-function z-c">print_i128</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c">c</span></span><span class="z-meta z-function-call z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-punctuation z-terminator z-c">;</span>
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"></span></span><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-end z-c">}</span></span></span>
</span><span class="z-source z-c">
</span><span class="z-source z-c"><span class="z-storage z-type z-c">int</span> <span class="z-meta z-function z-c"><span class="z-entity z-name z-function z-c">main</span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span></span></span><span class="z-meta z-function z-parameters z-c"><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-end z-c">)</span></span></span><span class="z-meta z-function z-c"> </span><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-begin z-c">{</span></span></span><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c">    <span class="z-storage z-type z-c">asm</span><span class="z-meta z-group z-c"><span class="z-punctuation z-section z-group z-begin z-c">(</span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">        <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> load arguments that fit in registers <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">        <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>movl    $0xaf, <span class="z-constant z-other z-placeholder z-c">%e</span>di <span class="z-constant z-character z-escape z-c">\n</span><span class="z-constant z-character z-escape z-c">\t</span><span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span>                <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> 1st slot (edi): padding char (`edi` is the
</span></span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c"><span class="z-comment z-block z-c">                                                   <span class="z-punctuation z-definition z-comment z-c">*</span> same as `rdi`, just a smaller access size) <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">        <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>movq    $0x9900aabbccddeeff, %rsi <span class="z-constant z-character z-escape z-c">\n</span><span class="z-constant z-character z-escape z-c">\t</span><span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span>  <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> 2nd slot (rsi): lower half of `a` <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">        <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>movq    $0x1122334455667788, %rdx <span class="z-constant z-character z-escape z-c">\n</span><span class="z-constant z-character z-escape z-c">\t</span><span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span>  <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> 3rd slot (rdx): upper half of `a` <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">        <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>movq    $0x9900aabbccddeeff, %rcx <span class="z-constant z-character z-escape z-c">\n</span><span class="z-constant z-character z-escape z-c">\t</span><span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span>  <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> 4th slot (rcx): lower half of `b` <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">        <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>movq    $0x1122334455667788, %r8  <span class="z-constant z-character z-escape z-c">\n</span><span class="z-constant z-character z-escape z-c">\t</span><span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span>  <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> 5th slot (r8):  upper half of `b` <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">        <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>movq    $0xdeadbeef4c0ffee0, %r9  <span class="z-constant z-character z-escape z-c">\n</span><span class="z-constant z-character z-escape z-c">\t</span><span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span>  <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> 6th slot (r9):  should be unused, but
</span></span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c"><span class="z-comment z-block z-c">                                                   <span class="z-punctuation z-definition z-comment z-c">*</span> let&#39;s trick clang! <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">        <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> reuse our stored registers to load the stack <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">        <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>pushq   %rdx <span class="z-constant z-character z-escape z-c">\n</span><span class="z-constant z-character z-escape z-c">\t</span><span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span>                       <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> upper half of `c` gets passed on the stack <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">        <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>pushq   %rsi <span class="z-constant z-character z-escape z-c">\n</span><span class="z-constant z-character z-escape z-c">\t</span><span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span>                       <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> lower half of `c` gets passed on the stack <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">        <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>call    foo <span class="z-constant z-character z-escape z-c">\n</span><span class="z-constant z-character z-escape z-c">\t</span><span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span>                        <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> call the function <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">        <span class="z-string z-quoted z-double z-c"><span class="z-punctuation z-definition z-string z-begin z-c">&quot;</span>addq    $16, %rsp <span class="z-constant z-character z-escape z-c">\n</span><span class="z-constant z-character z-escape z-c">\t</span><span class="z-punctuation z-definition z-string z-end z-c">&quot;</span></span>                  <span class="z-comment z-block z-c"><span class="z-punctuation z-definition z-comment z-c">/*</span> reset the stack <span class="z-punctuation z-definition z-comment z-c">*/</span></span>
</span></span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-meta z-group z-c">    <span class="z-punctuation z-section z-group z-end z-c">)</span></span><span class="z-punctuation z-terminator z-c">;</span>
</span></span></span><span class="z-source z-c"><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"></span></span><span class="z-meta z-function z-c"><span class="z-meta z-block z-c"><span class="z-punctuation z-section z-block z-end z-c">}</span></span></span>
</span></code></pre>
<p>Running the above with GCC prints the following expected output:</p>
<pre class="z-code"><code><span class="z-text z-plain">0xaf
</span><span class="z-text z-plain">0x11223344556677889900aabbccddeeff
</span><span class="z-text z-plain">0x11223344556677889900aabbccddeeff
</span><span class="z-text z-plain">0x11223344556677889900aabbccddeeff
</span></code></pre>
<p>But running with Clang 17 prints:</p>
<pre class="z-code"><code><span class="z-text z-plain">0xaf
</span><span class="z-text z-plain">0x11223344556677889900aabbccddeeff
</span><span class="z-text z-plain">0x11223344556677889900aabbccddeeff
</span><span class="z-text z-plain">0x9900aabbccddeeffdeadbeef4c0ffee0
</span><span class="z-text z-plain">//^^^^^^^^^^^^^^^^ this should be the lower half
</span><span class="z-text z-plain">//                ^^^^^^^^^^^^^^^^ look familiar?
</span></code></pre>
<p>Surprise!</p>
<p>This illustrates the second problem: LLVM expects an <code>i128</code> to be passed half in a
register and half on the stack when possible, but this is not allowed by the ABI.</p>
<p>Since the behavior comes from LLVM and has no reasonable workaround, this is a
problem in both Clang and Rust.</p>
<h1 id="solutions"><a class="anchor" href="#solutions" aria-hidden="true"></a>
Solutions</h1>
<p>Getting these problems resolved was a lengthy effort by many people, starting with a
patch by compiler team member Simonas Kazlauskas in 2017: <a href="https://reviews.llvm.org/D28990">D28990</a>. Unfortunately,
this wound up reverted. It was later attempted again in <a href="https://reviews.llvm.org/D86310">D86310</a> by LLVM contributor
Harald van Dijk, which is the version that finally landed in October 2023.</p>
<p>Around the same time, Nikita Popov fixed the calling convention issue with <a href="https://reviews.llvm.org/D158169">D158169</a>.
Both of these changes made it into LLVM 18, meaning all relevant ABI issues will be
resolved in both Clang and Rust that use this version (Clang 18 and Rust 1.78 when using
the bundled LLVM).</p>
<p>However, <code>rustc</code> can also use the version of LLVM installed on the system rather than a
bundled version, which may be older. To mitigate the chance of problems from differing
alignment with the same <code>rustc</code> version, <a href="https://github.com/rust-lang/compiler-team/issues/683">a proposal</a> was introduced to manually
correct the alignment like Clang has been doing. This was implemented by Matthew Maurer
in <a href="https://github.com/rust-lang/rust/pull/116672/">#116672</a>.</p>
<p>Since these changes, Rust now produces the correct alignment:</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-support z-macro z-rust">println!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>alignment of i128: <span class="z-constant z-other z-placeholder z-rust">{}</span><span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-separator z-rust">,</span> <span class="z-meta z-path z-rust">align_of<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-generic z-rust"><span class="z-punctuation z-definition z-generic z-begin z-rust">&lt;</span><span class="z-storage z-type z-rust">i128</span><span class="z-punctuation z-definition z-generic z-end z-rust">&gt;</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre>
<pre class="z-code"><code><span class="z-text z-plain">// rustc 1.77.0
</span><span class="z-text z-plain">alignment of i128: 16
</span></code></pre>
<p>As mentioned above, part of the reason for an ABI to specify the alignment of a datatype
is because it is more efficient on that architecture. We actually got to see that
firsthand: the <a href="https://github.com/rust-lang/rust/pull/116672/#issuecomment-1858600381">initial performance run</a> with the manual alignment change showed
nontrivial improvements to compiler performance (which relies heavily on 128-bit
integers to work with integer literals). The downside of increasing alignment is that
composite types do not always fit together as nicely in memory, leading to an increase
in usage. Unfortunately this meant some of the performance wins needed to be sacrificed
to avoid an increased memory footprint.</p>
<h1 id="compatibility"><a class="anchor" href="#compatibility" aria-hidden="true"></a>
Compatibility</h1>
<p>The most imporant question is how compatibility changed as a result of these fixes. In
short, <code>i128</code> and <code>u128</code> with Rust using LLVM 18 (the default version starting with
1.78) will be completely compatible with any version of GCC, as well as Clang 18 and
above (released March 2024). All other combinations have some incompatible cases, which
are summarized in the table below:</p>
<table><thead><tr><th>Compiler 1</th><th>Compiler 2</th><th>status</th></tr></thead><tbody>
<tr><td>Rust â‰¥ 1.78 with bundled LLVM (18)</td><td>GCC (any version)</td><td>Fully compatible</td></tr>
<tr><td>Rust â‰¥ 1.78 with bundled LLVM (18)</td><td>Clang â‰¥ 18</td><td>Fully compatible</td></tr>
<tr><td>Rust â‰¥ 1.77 with LLVM â‰¥ 18</td><td>GCC (any version)</td><td>Fully compatible</td></tr>
<tr><td>Rust â‰¥ 1.77 with LLVM â‰¥ 18</td><td>Clang â‰¥ 18</td><td>Fully compatible</td></tr>
<tr><td>Rust â‰¥ 1.77 with LLVM â‰¥ 18</td><td>Clang &lt; 18</td><td>Storage compatible, has calling bug</td></tr>
<tr><td>Rust â‰¥ 1.77 with LLVM &lt; 18</td><td>GCC (any version)</td><td>Storage compatible, has calling bug</td></tr>
<tr><td>Rust â‰¥ 1.77 with LLVM &lt; 18</td><td>Clang (any version)</td><td>Storage compatible, has calling bug</td></tr>
<tr><td>Rust &lt; 1.77<sup class="footnote-reference" id="fr-l-1"><a href="#fn-l">3</a></sup></td><td>GCC (any version)</td><td>Incompatible</td></tr>
<tr><td>Rust &lt; 1.77<sup class="footnote-reference" id="fr-l-2"><a href="#fn-l">3</a></sup></td><td>Clang (any version)</td><td>Incompatible</td></tr>
<tr><td>GCC (any version)</td><td>Clang â‰¥ 18</td><td>Fully compatible</td></tr>
<tr><td>GCC (any version)</td><td>Clang &lt; 18</td><td>Storage compatible with calling bug</td></tr>
</tbody></table>
<h1 id="effects-future-steps"><a class="anchor" href="#effects-future-steps" aria-hidden="true"></a>
Effects &amp; Future Steps</h1>
<p>As mentioned in the introduction, most users will notice no effects of this change
unless you are already doing something questionable with these types.</p>
<p>Starting with Rust 1.77, it will be reasonably safe to start experimenting with
128-bit integers in FFI, with some more certainty coming with the LLVM update
in 1.78. There is <a href="https://github.com/rust-lang/lang-team/issues/255">ongoing discussion</a> about lifting the lint in an upcoming
version, but we want to be cautious and avoid introducing silent breakage for users
whose Rust compiler may be built with an older LLVM.</p>
<footer class="footnotes">
<ol class="footnotes-list">
<li id="fn-f128-segfault">
<p><a href="https://bugs.llvm.org/show_bug.cgi?id=50198">https://bugs.llvm.org/show_bug.cgi?id=50198</a> <a href="#fr-f128-segfault-1">â†©</a></p>
</li>
<li id="fn-va-segfault">
<p><a href="https://github.com/llvm/llvm-project/issues/20283">https://github.com/llvm/llvm-project/issues/20283</a> <a href="#fr-va-segfault-1">â†©</a></p>
</li>
<li id="fn-l">
<p>Rust &lt; 1.77 with LLVM 18 will have some degree of compatibility, this is just
an uncommon combination. <a href="#fr-l-1">â†©</a> <a href="#fr-l-2">â†©2</a></p>
</li>
</ol>
</footer>

    </div>
  </div>
</section>
    <footer class="footer">
      <div class="w-100 mw-none ph3 mw8-m mw9-l center f3">
        <div class="row">
          <div class="four columns mt3 mt0-l" id="get-help">
            <h4>Get help!</h4>
            <ul>
              <li><a href="https://doc.rust-lang.org" target="_blank" rel="noopener">Documentation</a></li>
              <li><a href="mailto:core-team@rust-lang.org">Contact the Rust Team</a></li>
            </ul>
          </div>
          <div class="four columns mt3 mt0-l">
            <h4>Terms and policies</h4>
            <ul>
              <li><a href="https://www.rust-lang.org/policies/code-of-conduct">Code of Conduct</a></li>
              <li><a href="https://www.rust-lang.org/policies/licenses">Licenses</a></li>
              <li><a href="https://www.rust-lang.org/policies/media-guide">Logo Policy and Media Guide</a></li>
              <li><a href="https://www.rust-lang.org/policies/security">Security Disclosures</a></li>
              <li><a href="https://www.rust-lang.org/policies">All Policies</a></li>
            </ul>
          </div>
          <div class="four columns mt3 mt0-l">
            <h4>Social</h4>
            <div class="flex flex-row flex-wrap">
              <a rel="me" href="https://social.rust-lang.org/@rust" target="_blank" rel="noopener" alt="mastodon link"><img src="https://blog.rust-lang.org/images/mastodon.svg" alt="mastodon logo" title="Mastodon"/></a>
              <a rel="me" href="https://bsky.app/profile/rust-lang.org" target="_blank" rel="noopener" alt="Bluesky link"><img src="https://blog.rust-lang.org/images/bluesky.svg" alt="Bluesky logo" title="Bluesky"/></a>
              <a href="https://www.youtube.com/channel/UCaYhcUwRBNscFNUKTjgPFiA" target="_blank" rel="noopener" alt="youtube link"><img style="padding-top: 6px; padding-bottom:6px" src="https://blog.rust-lang.org/images/youtube.svg" alt="youtube logo" title="YouTube"/></a>
              <a href="https://discord.gg/rust-lang" target="_blank" rel="noopener" alt="discord link"><img src="https://blog.rust-lang.org/images/discord.svg" alt="discord logo" title="Discord"/></a>
              <a href="https://github.com/rust-lang" target="_blank" rel="noopener" alt="github link"><img src="https://blog.rust-lang.org/images/github.svg" alt="github logo" title="GitHub"/></a>
            </div>
            <h4 class="mt4 mb3">RSS</h4>
            <ul>
              <li><a href="https://blog.rust-lang.org/feed.xml">Main Blog</a></li>
              <li><a href="https://blog.rust-lang.org/inside-rust/feed.xml">"Inside Rust" Blog</a></li>
            </ul>
          </div>
    
        </div>
        <div class="attribution">
          Maintained by the Rust Team. See a typo?
          <a href="https://github.com/rust-lang/blog.rust-lang.org/edit/master/content/i128-layout-update.md" target="_blank" rel="noopener">Send a fix here</a>!
        </div>
      </div>
    </footer>
  </body>
</html>
